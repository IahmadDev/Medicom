{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.default = normalizeModuleAndLoadMetadata;\n\nvar _path = require(\"path\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\n\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\n\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\n  noInterop = false,\n  loose = false,\n  lazy = false,\n  esNamespaceOnly = false\n} = {}) {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n\n  const stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    loose,\n    lazy\n  }, stringSpecifiers);\n  removeModuleDeclarations(programPath);\n\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    if (noInterop) metadata.interop = \"none\";else if (esNamespaceOnly) {\n      if (metadata.interop === \"namespace\") {\n        metadata.interop = \"default\";\n      }\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers\n  };\n}\n\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\n  }\n}\n\nfunction getModuleMetadata(programPath, {\n  loose,\n  lazy\n}, stringSpecifiers) {\n  const localData = getLocalExportMetadata(programPath, loose, stringSpecifiers);\n  const sourceData = new Map();\n\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false\n      };\n      sourceData.set(source, data);\n    }\n\n    return data;\n  };\n\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (!spec.isExportSpecifier()) {\n          throw spec.buildCodeFrameError(\"Unexpected export specifier type\");\n        }\n\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw exportName.buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\n\nfunction getLocalExportMetadata(programPath, loose, stringSpecifiers) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\n\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (loose && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.node.specifiers.forEach(specifier => {\n            bindingKindLookup.set(specifier.local.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\n\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/92320/Documents/5th Semester/SE/Medicom/frontend/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"],"names":["Object","defineProperty","exports","value","hasExports","isSideEffectImport","default","normalizeModuleAndLoadMetadata","_path","require","_helperValidatorIdentifier","_helperSplitExportDeclaration","_interopRequireDefault","obj","__esModule","metadata","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","programPath","exportName","noInterop","loose","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","getModuleMetadata","removeModuleDeclarations","values","next","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","isIdentifierName","add","Error","type","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","basename","extname","loc","set","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportSpecifier","buildCodeFrameError","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","bindingKindLookup","kind","declaration","specifiers","specifier","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","remove","_blockHoist","replaceWith"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.hasExports = hasExports;\r\nexports.isSideEffectImport = isSideEffectImport;\r\nexports.default = normalizeModuleAndLoadMetadata;\r\n\r\nvar _path = require(\"path\");\r\n\r\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\r\n\r\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction hasExports(metadata) {\r\n  return metadata.hasExports;\r\n}\r\n\r\nfunction isSideEffectImport(source) {\r\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\r\n}\r\n\r\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\r\n  noInterop = false,\r\n  loose = false,\r\n  lazy = false,\r\n  esNamespaceOnly = false\r\n} = {}) {\r\n  if (!exportName) {\r\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\r\n  }\r\n\r\n  const stringSpecifiers = new Set();\r\n  nameAnonymousExports(programPath);\r\n  const {\r\n    local,\r\n    source,\r\n    hasExports\r\n  } = getModuleMetadata(programPath, {\r\n    loose,\r\n    lazy\r\n  }, stringSpecifiers);\r\n  removeModuleDeclarations(programPath);\r\n\r\n  for (const [, metadata] of source) {\r\n    if (metadata.importsNamespace.size > 0) {\r\n      metadata.name = metadata.importsNamespace.values().next().value;\r\n    }\r\n\r\n    if (noInterop) metadata.interop = \"none\";else if (esNamespaceOnly) {\r\n      if (metadata.interop === \"namespace\") {\r\n        metadata.interop = \"default\";\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    exportName,\r\n    exportNameListName: null,\r\n    hasExports,\r\n    local,\r\n    source,\r\n    stringSpecifiers\r\n  };\r\n}\r\n\r\nfunction getExportSpecifierName(path, stringSpecifiers) {\r\n  if (path.isIdentifier()) {\r\n    return path.node.name;\r\n  } else if (path.isStringLiteral()) {\r\n    const stringValue = path.node.value;\r\n\r\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\r\n      stringSpecifiers.add(stringValue);\r\n    }\r\n\r\n    return stringValue;\r\n  } else {\r\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\r\n  }\r\n}\r\n\r\nfunction getModuleMetadata(programPath, {\r\n  loose,\r\n  lazy\r\n}, stringSpecifiers) {\r\n  const localData = getLocalExportMetadata(programPath, loose, stringSpecifiers);\r\n  const sourceData = new Map();\r\n\r\n  const getData = sourceNode => {\r\n    const source = sourceNode.value;\r\n    let data = sourceData.get(source);\r\n\r\n    if (!data) {\r\n      data = {\r\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\r\n        interop: \"none\",\r\n        loc: null,\r\n        imports: new Map(),\r\n        importsNamespace: new Set(),\r\n        reexports: new Map(),\r\n        reexportNamespace: new Set(),\r\n        reexportAll: null,\r\n        lazy: false\r\n      };\r\n      sourceData.set(source, data);\r\n    }\r\n\r\n    return data;\r\n  };\r\n\r\n  let hasExports = false;\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isImportDeclaration()) {\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      child.get(\"specifiers\").forEach(spec => {\r\n        if (spec.isImportDefaultSpecifier()) {\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.imports.set(localName, \"default\");\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexports.set(name, \"default\");\r\n            });\r\n          }\r\n        } else if (spec.isImportNamespaceSpecifier()) {\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.importsNamespace.add(localName);\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexportNamespace.add(name);\r\n            });\r\n          }\r\n        } else if (spec.isImportSpecifier()) {\r\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\r\n          const localName = spec.get(\"local\").node.name;\r\n          data.imports.set(localName, importName);\r\n          const reexport = localData.get(localName);\r\n\r\n          if (reexport) {\r\n            localData.delete(localName);\r\n            reexport.names.forEach(name => {\r\n              data.reexports.set(name, importName);\r\n            });\r\n          }\r\n        }\r\n      });\r\n    } else if (child.isExportAllDeclaration()) {\r\n      hasExports = true;\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      data.reexportAll = {\r\n        loc: child.node.loc\r\n      };\r\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\r\n      hasExports = true;\r\n      const data = getData(child.node.source);\r\n      if (!data.loc) data.loc = child.node.loc;\r\n      child.get(\"specifiers\").forEach(spec => {\r\n        if (!spec.isExportSpecifier()) {\r\n          throw spec.buildCodeFrameError(\"Unexpected export specifier type\");\r\n        }\r\n\r\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\r\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\r\n        data.reexports.set(exportName, importName);\r\n\r\n        if (exportName === \"__esModule\") {\r\n          throw exportName.buildCodeFrameError('Illegal export \"__esModule\".');\r\n        }\r\n      });\r\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\r\n      hasExports = true;\r\n    }\r\n  });\r\n\r\n  for (const metadata of sourceData.values()) {\r\n    let needsDefault = false;\r\n    let needsNamed = false;\r\n\r\n    if (metadata.importsNamespace.size > 0) {\r\n      needsDefault = true;\r\n      needsNamed = true;\r\n    }\r\n\r\n    if (metadata.reexportAll) {\r\n      needsNamed = true;\r\n    }\r\n\r\n    for (const importName of metadata.imports.values()) {\r\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\r\n    }\r\n\r\n    for (const importName of metadata.reexports.values()) {\r\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\r\n    }\r\n\r\n    if (needsDefault && needsNamed) {\r\n      metadata.interop = \"namespace\";\r\n    } else if (needsDefault) {\r\n      metadata.interop = \"default\";\r\n    }\r\n  }\r\n\r\n  for (const [source, metadata] of sourceData) {\r\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\r\n      if (lazy === true) {\r\n        metadata.lazy = !/\\./.test(source);\r\n      } else if (Array.isArray(lazy)) {\r\n        metadata.lazy = lazy.indexOf(source) !== -1;\r\n      } else if (typeof lazy === \"function\") {\r\n        metadata.lazy = lazy(source);\r\n      } else {\r\n        throw new Error(`.lazy must be a boolean, string array, or function`);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    hasExports,\r\n    local: localData,\r\n    source: sourceData\r\n  };\r\n}\r\n\r\nfunction getLocalExportMetadata(programPath, loose, stringSpecifiers) {\r\n  const bindingKindLookup = new Map();\r\n  programPath.get(\"body\").forEach(child => {\r\n    let kind;\r\n\r\n    if (child.isImportDeclaration()) {\r\n      kind = \"import\";\r\n    } else {\r\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\r\n\r\n      if (child.isExportNamedDeclaration()) {\r\n        if (child.node.declaration) {\r\n          child = child.get(\"declaration\");\r\n        } else if (loose && child.node.source && child.get(\"source\").isStringLiteral()) {\r\n          child.node.specifiers.forEach(specifier => {\r\n            bindingKindLookup.set(specifier.local.name, \"block\");\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (child.isFunctionDeclaration()) {\r\n        kind = \"hoisted\";\r\n      } else if (child.isClassDeclaration()) {\r\n        kind = \"block\";\r\n      } else if (child.isVariableDeclaration({\r\n        kind: \"var\"\r\n      })) {\r\n        kind = \"var\";\r\n      } else if (child.isVariableDeclaration()) {\r\n        kind = \"block\";\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n\r\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\r\n      bindingKindLookup.set(name, kind);\r\n    });\r\n  });\r\n  const localMetadata = new Map();\r\n\r\n  const getLocalMetadata = idPath => {\r\n    const localName = idPath.node.name;\r\n    let metadata = localMetadata.get(localName);\r\n\r\n    if (!metadata) {\r\n      const kind = bindingKindLookup.get(localName);\r\n\r\n      if (kind === undefined) {\r\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\r\n      }\r\n\r\n      metadata = {\r\n        names: [],\r\n        kind\r\n      };\r\n      localMetadata.set(localName, metadata);\r\n    }\r\n\r\n    return metadata;\r\n  };\r\n\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {\r\n      if (child.node.declaration) {\r\n        const declaration = child.get(\"declaration\");\r\n        const ids = declaration.getOuterBindingIdentifierPaths();\r\n        Object.keys(ids).forEach(name => {\r\n          if (name === \"__esModule\") {\r\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\r\n          }\r\n\r\n          getLocalMetadata(ids[name]).names.push(name);\r\n        });\r\n      } else {\r\n        child.get(\"specifiers\").forEach(spec => {\r\n          const local = spec.get(\"local\");\r\n          const exported = spec.get(\"exported\");\r\n          const localMetadata = getLocalMetadata(local);\r\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\r\n\r\n          if (exportName === \"__esModule\") {\r\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\r\n          }\r\n\r\n          localMetadata.names.push(exportName);\r\n        });\r\n      }\r\n    } else if (child.isExportDefaultDeclaration()) {\r\n      const declaration = child.get(\"declaration\");\r\n\r\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\r\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\r\n      } else {\r\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\r\n      }\r\n    }\r\n  });\r\n  return localMetadata;\r\n}\r\n\r\nfunction nameAnonymousExports(programPath) {\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (!child.isExportDefaultDeclaration()) return;\r\n    (0, _helperSplitExportDeclaration.default)(child);\r\n  });\r\n}\r\n\r\nfunction removeModuleDeclarations(programPath) {\r\n  programPath.get(\"body\").forEach(child => {\r\n    if (child.isImportDeclaration()) {\r\n      child.remove();\r\n    } else if (child.isExportNamedDeclaration()) {\r\n      if (child.node.declaration) {\r\n        child.node.declaration._blockHoist = child.node._blockHoist;\r\n        child.replaceWith(child.node.declaration);\r\n      } else {\r\n        child.remove();\r\n      }\r\n    } else if (child.isExportDefaultDeclaration()) {\r\n      const declaration = child.get(\"declaration\");\r\n\r\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\r\n        declaration._blockHoist = child.node._blockHoist;\r\n        child.replaceWith(declaration);\r\n      } else {\r\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\r\n      }\r\n    } else if (child.isExportAllDeclaration()) {\r\n      child.remove();\r\n    }\r\n  });\r\n}"]},"metadata":{},"sourceType":"script"}